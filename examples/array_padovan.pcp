fn add(a: int, b: int) -> int {
    asm {
        "        lw      r1,-8(r30)",
        "        lw      r2,-4(r30)",
        "        add     r1,r1,r2",
    }
}

fn sub(a: int, b: int) -> int {
    asm {
        "        lw      r1,-8(r30)",
        "        lw      r2,-4(r30)",
        "        sub     r1,r1,r2",
    }
}

fn less_than(a: int, b: int) -> bool {
    asm {
        "        lw      r1,-8(r30)",
        "        lw      r2,-4(r30)",
        "        slt     r1,r1,r2",
    }
}

fn less_than_eq(a: int, b: int) -> bool {
    asm {
        "        lw      r1,-8(r30)",
        "        lw      r2,-4(r30)",
        "        sle     r1,r1,r2",
    }
}

fn heap_alloc(size: int) -> *any {
    asm {
        # Get the size of the allocation
        "        lw    r2,-4(r30)",
        # Set the return value to be the next address
        "        addu  r1,r15,r0",
        # Set the address of the next chunk
        "        addu  r15,r15,r2",
    }
}

# Compute the nth padovan number recursively
fn pad(n: int) -> int {
    if (less_than(n, 3)) {
        return 1;
    }

    add(pad(sub(n, 2)), pad(sub(n, 3)))
}

# Compute the sum of all padovan numbers up to n
fn padSum(low: int, high: int, step: int) -> int {
    if (less_than(low, 0)) {
        return -1;
    }
    if (less_than(high, low)) {
        return -1;
    }
    if (less_than(step, 1)) {
        return -1;
    }
    
    let i = low;
    let result = 0;
    while (less_than_eq(i, high)) {
        result = add(result, pad(i));
        i = add(i, step);
    }
    
    result
}

let result_arr: [int, ..5];

fn main() {   
    #result_arr = heap_alloc(20) as *int;
    
    result_arr[0] = padSum(0, 5, 1);
    result_arr[1] = padSum(2, 11, 2);
    result_arr[2] = padSum(5, 2, 1);
    result_arr[3] = padSum(2, 10, -1);
    result_arr[4] = add(result_arr[0], result_arr[1]);
}
